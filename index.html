<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Ultimate Chat App</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --light-bg: #f0f2f5; --light-text: #111b21; --light-primary: #00a884; --light-secondary: #ffffff;
            --light-input-border: #ddd; --light-message-sent-bg: #dcf8c6; --light-icon-color: #54656f;
            --dark-bg: #0d1418; --dark-text: #e9edef;
            --dark-primary: #007a62; --dark-secondary: #1f2c33; --dark-input-border: #374045;
            --dark-message-sent-bg: #054740; --dark-icon-color: #aebac1; 
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--light-bg); color: var(--light-text); transition: background 0.3s, color 0.3s; }
        .dark-theme { background: var(--dark-bg); color: var(--dark-text); }
        .dark-theme .input-box { background: var(--dark-secondary); color: var(--dark-text); border-color: var(--dark-input-border); }
        .dark-theme .message { background: var(--dark-secondary); color: var(--dark-text); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .dark-theme .message.sent { background: var(--dark-message-sent-bg); }
        .dark-theme .chat-header { background: var(--dark-primary); }
        .dark-theme .action-btn { background: linear-gradient(145deg, var(--dark-primary), #00634e); }
        .dark-theme #theme-toggle { background: var(--dark-secondary); color: var(--dark-text); } 
        .dark-theme .app-title { color: var(--dark-text); }
        .dark-theme #copy-id-btn { color: var(--dark-primary); }
        .dark-theme .chat-input-area { background: var(--dark-secondary); border-top-color: var(--dark-input-border); }
        .dark-theme #message-input { color: var(--dark-text); background-color: var(--dark-secondary); border-color: var(--dark-input-border); }
        .dark-theme #send-chat-btn { background-color: var(--dark-primary); }
        .dark-theme .chat-header-actions button { color: var(--dark-text); }
        .dark-theme .message.system { color: #aaa; }
        .dark-theme .incoming-call-prompt { background: var(--dark-secondary); color: var(--dark-text); }
        .dark-theme .incoming-call-prompt .accept-call { background-color: var(--dark-primary); }
        .dark-theme .incoming-call-prompt .reject-call { background-color: #555; color: var(--dark-text); }
        .dark-theme #call-controls button { background-color: var(--dark-primary); }
        .dark-theme #call-controls button.hang-up { background-color: #cc3737; }


        #theme-toggle { position: fixed; top: 15px; right: 15px; padding: 10px; width: 40px; height: 40px; border: none; border-radius: 50%; background: var(--light-primary); color: white; cursor: pointer; z-index: 2001; box-shadow: 0 2px 5px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; }
        .container { max-width: 600px; margin: 0 auto; min-height: 100vh; padding: 20px; position: relative; }
        #home-page { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .app-title { color: var(--light-primary); margin: 2rem 0; font-size: 2.5rem; }
        .input-container { position: relative; width: 100%; margin: 10px 0; }
        .input-box { width: 100%; padding: 15px; border: 2px solid var(--light-input-border); border-radius: 25px; background: var(--light-secondary); box-shadow: 0 3px 10px rgba(0,0,0,0.1); font-size: 1rem; }
        #peer-id.input-box { padding-right: 45px; } #friend-name.input-box { padding-right: 15px; }
        #copy-id-btn { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--light-primary); display: none; }
        .action-btn { width: 100%; padding: 15px; margin: 10px 0; border: none; border-radius: 15px; background: linear-gradient(145deg, #00a884, #008f72); color: white; cursor: pointer; box-shadow: 0 5px 15px rgba(0,0,0,0.2); font-size: 1.1rem; font-weight: bold; }
        #chat-page { display: none; flex-direction: column; height: 100vh; }
        .chat-header { padding: 10px 15px; background: var(--light-primary); color: white; border-radius: 15px; margin-bottom: 15px; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .chat-header-info { text-align: left; flex-grow: 1; } .chat-header-info h2 { font-size: 1.2rem; margin-bottom: 2px; } .chat-header-info div { font-size: 0.8rem; opacity: 0.9; }
        .chat-header-actions button { background: none; border: none; color: white; font-size: 1.5rem; margin-left: 10px; cursor: pointer; padding: 5px; }
        #messages { flex-grow: 1; overflow-y: auto; padding: 10px; }
        .message { background: var(--light-secondary); color: var(--light-text); padding: 10px 15px; border-radius: 18px; margin: 10px 0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-width: 80%; word-wrap: break-word; }
        .message.sent { background: var(--light-message-sent-bg); margin-left: auto; text-align: right; }
        .message.received { margin-right: auto; text-align: left; }
        .message.system { font-style: italic; color: #666; text-align: center; max-width: 100%; background: transparent; box-shadow: none; font-size: 0.9em; }
        .error-msg { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #ff4444; color: white; padding: 12px 20px; border-radius: 25px; display: none; z-index: 2000; box-shadow: 0 3px 10px rgba(0,0,0,0.2); font-size: 0.9rem; text-align: center; }
        
        .chat-input-area { 
            padding: 10px; background: var(--light-secondary); 
            border-top: 1px solid var(--light-input-border);
            flex-shrink: 0; 
            display: flex; 
            align-items: center; 
        }
        #message-input { 
            flex-grow: 1;
            padding: 12px 15px; 
            border: 2px solid var(--light-input-border);
            border-radius: 25px;
            outline: none;
            background: var(--light-secondary); 
            font-size: 1rem;
            color: var(--light-text);
            margin-right: 10px; 
        }
        #send-chat-btn { 
            background-color: var(--light-primary); color: white; border: none;
            border-radius: 50%; width: 48px; height: 48px; font-size: 1.5rem; 
            padding: 0; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); flex-shrink: 0; 
        }
        #send-chat-btn:hover { opacity: 0.9; }
        .icon-btn { /* General style for icon buttons in header and call controls */
            background: none; border: none; 
            color: var(--light-icon-color); cursor: pointer; 
            padding: 8px; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; /* Default icon size for call controls */
        }
        .chat-header-actions .icon-btn { color: white; } /* Header icons are white */
        .dark-theme .chat-header-actions .icon-btn { color: var(--dark-text); }


        /* Video Call Styles */
        #video-call-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1005; padding: 10px; }
        .video-wrapper { position: relative; width: 100%; max-width: 580px; aspect-ratio: 4 / 3; background-color: #000; margin-bottom: 10px; border-radius: 8px; overflow: hidden;}
        #remote-video { width: 100%; height: 100%; object-fit: cover; }
        #local-video { position: absolute; bottom: 15px; right: 15px; width: 25%; max-width: 120px; height: auto; aspect-ratio: 3 / 4; border: 2px solid white; z-index: 1006; display: none; border-radius: 4px;}
        #call-controls { display: flex; gap: 15px; margin-top: 10px; }
        #call-controls button { background-color: var(--light-primary); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; display: flex; align-items: center; justify-content: center; } /* font-size is inherited from .icon-btn */
        #call-controls button.hang-up { background-color: #ff4444; }
        .dark-theme #call-controls button { background-color: var(--dark-primary); }
        .dark-theme #call-controls button.hang-up { background-color: #cc3737; }

        .incoming-call-prompt { background: var(--light-secondary); color: var(--light-text); padding: 15px; border-radius: 10px; margin: 10px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.2); text-align: center; max-width: 90%; }
        .dark-theme .incoming-call-prompt { background: var(--dark-secondary); color: var(--dark-text); }
        .incoming-call-prompt p { margin-bottom: 10px; }
        .incoming-call-prompt button { padding: 8px 15px; margin: 0 5px; border-radius: 5px; border: none; cursor: pointer; }
        .incoming-call-prompt .accept-call { background-color: var(--light-primary); color: white; }
        .incoming-call-prompt .reject-call { background-color: #ccc; color: #333; }
        .dark-theme .incoming-call-prompt .accept-call { background-color: var(--dark-primary); }
        .dark-theme .incoming-call-prompt .reject-call { background-color: #555; color: var(--dark-text); }
    </style>
</head>
<body>
    <button id="theme-toggle">üåô</button>
    <div class="error-msg">‚ö†Ô∏è Error Message Placeholder</div>

    <div id="home-page" class="container">
        <h1 class="app-title">üí¨ Ultimate Chat</h1>
        <input type="text" id="friend-name" placeholder="Your Name (Optional) ‚úçÔ∏è" class="input-box">
        <div class="input-container">
            <input type="text" id="peer-id" placeholder="Your ID / Friend's ID üîë" class="input-box">
            <button id="copy-id-btn" title="Copy ID">üìã</button>
        </div>
        <button class="action-btn" onclick="createNewChat()">üÜî Create My ID</button>
        <button class="action-btn" onclick="startChat()">üöÄ Connect to Friend</button>
    </div>

    <div id="chat-page" class="container">
        <div class="chat-header">
            <div class="chat-header-info">
                <h2>Chatting with: <span id="contact-name">Friend</span></h2>
                <div id="connection-status">üîí P2P Encrypted</div>
            </div>
            <div class="chat-header-actions">
                <button id="audio-call-btn" class="icon-btn" title="Audio Call">üìû</button>
                <button id="video-call-btn" class="icon-btn" title="Video Call">üìπ</button>
            </div>
        </div>
        <div id="messages"></div>
        <div class="chat-input-area">
            <input type="text" id="message-input" placeholder="Type a message...">
            <button id="send-chat-btn" title="Send">üì§</button> <!-- Removed class="icon-btn" to use specific #send-chat-btn styles -->
        </div>
    </div>

    <div id="video-call-container">
        <div class="video-wrapper">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>
        <div id="call-controls">
            <button id="toggle-mic-btn" class="icon-btn" title="Mute/Unmute Mic">üé§</button>
            <button id="toggle-video-btn" class="icon-btn" title="Turn Video On/Off">üìπ</button>
            <button id="toggle-speaker-btn" class="icon-btn" title="Toggle Speaker">üîä</button>
            <button id="hang-up-btn" class="icon-btn hang-up" title="Hang Up">üìû</button>
        </div>
    </div>

    <script>
        // ----- Global Variables ----- 
        let peer; let conn; let myPeerId = null; let connectToFriendIdAfterInitialize = null; 
        let localStream = null; 
        let currentCall = null; 
        let incomingCallInstance = null;
        let isSpeakerphoneOn = false; // To track speaker state for toggle

        // ----- DOM Elements ----- 
        const themeToggle = document.getElementById('theme-toggle'); const errorMsgEl = document.querySelector('.error-msg'); const copyIdBtn = document.getElementById('copy-id-btn'); const peerIdInput = document.getElementById('peer-id'); const friendNameInput = document.getElementById('friend-name'); const contactNameSpan = document.getElementById('contact-name'); const messagesDiv = document.getElementById('messages'); const messageInput = document.getElementById('message-input'); const homePageEl = document.getElementById('home-page'); const chatPageEl = document.getElementById('chat-page'); 
        const audioCallBtn = document.getElementById('audio-call-btn'); 
        const videoCallBtn = document.getElementById('video-call-btn'); 
        const sendChatBtn = document.getElementById('send-chat-btn');
        const connectionStatusEl = document.getElementById('connection-status');
        const videoCallContainer = document.getElementById('video-call-container');
        const localVideoEl = document.getElementById('local-video');
        const remoteVideoEl = document.getElementById('remote-video');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const toggleVideoBtn = document.getElementById('toggle-video-btn');
        const toggleSpeakerBtn = document.getElementById('toggle-speaker-btn');
        const hangUpBtn = document.getElementById('hang-up-btn');

        // ----- Event Listeners Setup ----- 
        function setupEventListeners() {
            themeToggle.addEventListener('click', () => { document.body.classList.toggle('dark-theme'); const isDark = document.body.classList.contains('dark-theme'); themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô'; localStorage.setItem('theme', isDark ? 'dark' : 'light'); });
            copyIdBtn.addEventListener('click', () => { if (peerIdInput.value) { navigator.clipboard.writeText(peerIdInput.value).then(() => showError('‚úÖ ID Copied!')).catch(err => { console.error('Copy failed: ', err); showError('‚ùå Copy failed.'); }); } else { showError('ü§î No ID to copy.'); }});
            messageInput.addEventListener('keypress', (event) => { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); } });
            sendChatBtn.addEventListener('click', sendMessage);
            
            audioCallBtn.addEventListener('click', () => startCallAttempt('audio'));
            videoCallBtn.addEventListener('click', () => startCallAttempt('video'));
            hangUpBtn.addEventListener('click', endCall);
            toggleMicBtn.addEventListener('click', toggleMicrophone);
            toggleVideoBtn.addEventListener('click', toggleCamera);
            toggleSpeakerBtn.addEventListener('click', toggleSpeaker);
        }

        // ----- Theme Logic ----- 
        function applySavedTheme() { if (localStorage.getItem('theme') === 'dark') { document.body.classList.add('dark-theme'); themeToggle.textContent = '‚òÄÔ∏è'; } else { document.body.classList.remove('dark-theme'); themeToggle.textContent = 'üåô'; }}

        // ----- UI Helper Functions ----- 
        function showError(text, duration = 4000) { console.log(`SHOW_ERROR: ${text}`); errorMsgEl.textContent = text; errorMsgEl.style.display = 'block'; setTimeout(() => { errorMsgEl.style.display = 'none'; }, duration); }
        
        // ----- Core PeerJS Logic ----- 
        function initializePeer() { 
            console.log("PEER_INIT: Initializing Peer..."); 
            if (peer) { console.log("PEER_INIT: Destroying existing peer instance."); peer.destroy(); } 
            peer = new Peer(undefined, { host: '0.peerjs.com', port: 443, secure: true, debug: 1, config: {iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, ]} });  
            
            peer.on('open', id => { console.log('PEER_OPEN: My peer ID is: ' + id); myPeerId = id; peerIdInput.value = id; copyIdBtn.style.display = 'inline-block'; if (connectToFriendIdAfterInitialize) { showError(`‚úÖ Client ready (ID: ${myPeerId}). Attempting to connect to ${connectToFriendIdAfterInitialize}...`); attemptActualConnection(connectToFriendIdAfterInitialize); connectToFriendIdAfterInitialize = null; } else { showError(`üéâ Your Connection ID: ${myPeerId}. Share it!`); }});  
            peer.on('connection', incomingConn => { console.log("PEER_CONN_INCOMING: From:", incomingConn.peer, "Metadata:", incomingConn.metadata); if (conn && conn.open) { console.log("PEER_CONN_INCOMING: Already connected via DataChannel. Rejecting new DataChannel from " + incomingConn.peer); incomingConn.close(); showError("‚ö†Ô∏è Busy with data connection. New data connection rejected."); return; } conn = incomingConn; let friendDisplayName = (conn.metadata && conn.metadata.name && conn.metadata.name !== "Anonymous") ? conn.metadata.name : `Friend (${conn.peer.slice(-6)})`; console.log(`PEER_CONN_INCOMING: Setting up events for incoming DataConnection with ${friendDisplayName}`); setupDataConnectionEvents(conn, friendDisplayName);});  
            
            peer.on('call', incomingMediaCall => {
                console.log("PEER_MEDIA_CALL_INCOMING: From", incomingMediaCall.peer, "Metadata:", incomingMediaCall.metadata);
                if (currentCall || incomingCallInstance) { console.warn("PEER_MEDIA_CALL_INCOMING: Already in a call or has a pending call. Rejecting new call from", incomingMediaCall.peer); incomingMediaCall.close(); return; }
                incomingCallInstance = incomingMediaCall; 
                const callType = incomingMediaCall.metadata && incomingMediaCall.metadata.callType ? incomingMediaCall.metadata.callType : "unknown";
                const callerName = (conn && conn.peer === incomingMediaCall.peer && conn.metadata && conn.metadata.name) ? conn.metadata.name : (incomingMediaCall.metadata.callerName || incomingMediaCall.peer);
                showIncomingCallPrompt(callerName, callType);
            });

            peer.on('disconnected', () => { console.warn("PEER_DISCONNECTED: From signaling server."); showError("‚ÄºÔ∏è Disconnected from PeerJS server. Will attempt to reconnect."); });  
            peer.on('close', () => { console.warn("PEER_CLOSE: Peer instance closed."); showError("üõë Peer instance closed. Create a new ID if needed.", 6000); myPeerId = null; if (peerIdInput.value === (peer && peer.id)) peerIdInput.value = ''; copyIdBtn.style.display = 'none'; endCallCleanup(); /* Clean up call state if peer obj closes */ });  
            peer.on('error', err => { console.error('PEER_ERROR: Main error:', err); let message = `‚ö†Ô∏è PeerJS Error (${err.type || 'Unknown'})`; if (err.type === 'network') message = 'üåê Network error with PeerJS server.'; else if (err.type === 'peer-unavailable') message = `‚ùå Friend with ID '${String(err.message).split(' ').pop()}' not found.`; else if (err.type === 'webrtc') message = 'üï∏Ô∏è WebRTC connection error.'; else if (err.type === 'server-error') message = `üîå PeerJS server error: ${err.message || 'Unknown'}.`; else if (err.type === 'socket-error') message = `üîå Socket error.`; else if (err.type === 'socket-closed') message = `üîå Connection to PeerJS server closed.`; else message = `‚ö†Ô∏è PeerJS Error: ${err.message || err.type}`; showError(message, 7000); endCallCleanup(); /* Clean up call state on major peer error */});  
        }
        function createNewChat() { console.log("UI_ACTION: Create New Chat clicked."); connectToFriendIdAfterInitialize = null; peerIdInput.value = ''; initializePeer(); }
        function startChat() { const friendIdToConnect = peerIdInput.value.trim(); console.log(`UI_ACTION: Start Chat clicked. To: ${friendIdToConnect}`); if (!friendIdToConnect) { showError('üîó Enter friend\'s Connection ID.'); return; } if (conn && conn.open && conn.peer === friendIdToConnect) { showError("üí¨ Already connected to this friend."); switchToChatPage(); return; } if (conn && conn.open && conn.peer !== friendIdToConnect) { showError("üí¨ Connected to someone else. Disconnect or refresh first."); return; } if (friendIdToConnect === myPeerId) { showError('ü§î This is your ID. Share it! Friend uses "Connect" button.'); return; } if (!peer || !peer.id || !myPeerId) { console.log("UI_ACTION: Peer not initialized. Initializing to connect to " + friendIdToConnect); showError("‚è≥ Initializing your client. Will attempt connection shortly..."); connectToFriendIdAfterInitialize = friendIdToConnect; initializePeer(); return; } if (peer && peer.open) { console.log("UI_ACTION: Peer is open. Attempting direct connection to " + friendIdToConnect); attemptActualConnection(friendIdToConnect); } else { console.log("UI_ACTION: Peer exists but not open. Will connect when peer is open to " + friendIdToConnect); showError("‚è≥ Your client is preparing. Will connect when ready..."); connectToFriendIdAfterInitialize = friendIdToConnect;}}
        
        function attemptActualConnection(targetPeerId) {
            console.log(`CONN_ATTEMPT: To ${targetPeerId}`); if (!peer || !peer.open) { console.warn("CONN_ATTEMPT: Peer not open."); showError("‚è≥ Client not ready.", 5000); connectToFriendIdAfterInitialize = targetPeerId; if (!peer) initializePeer(); return; }
            const myNameToShare = friendNameInput.value.trim() || "Anonymous";
            if (conn && conn.open && conn.peer !== targetPeerId) { console.log(`CONN_ATTEMPT: Closing existing DataConnection with ${conn.peer}`); conn.close(); }
            
            conn = peer.connect(targetPeerId, { metadata: { name: myNameToShare }, reliable: true, serialization: 'binary' }); 
            console.log(`CONN_ATTEMPT: DataConnection object created for ${targetPeerId}. Setting up events.`); 
            setupDataConnectionEvents(conn, `Friend (${targetPeerId.slice(-6)})`);
        }
        
        function setupDataConnectionEvents(dataConnection, initialContactName) {
            console.log(`SETUP_DATA_CONN_EVENTS: For ${dataConnection.peer}.`);
            dataConnection.removeAllListeners(); 
            dataConnection.on('open', () => {
                console.log(`DATA_CONN_OPEN: With ${dataConnection.peer}.`);
                let currentContactName = initialContactName;
                if (dataConnection.metadata && dataConnection.metadata.name && dataConnection.metadata.name !== "Anonymous") {
                    currentContactName = dataConnection.metadata.name;
                }
                contactNameSpan.textContent = currentContactName;
                messagesDiv.innerHTML = ''; 
                switchToChatPage(); 
                showError(`‚úÖ Connected to ${currentContactName}!`, 5000);
            });
            dataConnection.on('data', data => { 
                let logData = data; if (typeof data === 'string' && data.length > 200) logData = `String (length: ${data.length}), first 200: ${data.substring(0,200)}`; console.log(`DATA_RECV: Raw from ${dataConnection.peer}: Type: ${typeof data}`, logData);
                if (typeof data === 'string') { 
                    try { const decodedText = decodeURIComponent(escape(atob(data))); console.log(`DATA_RECV_STRING: Decoded: "${decodedText}"`); appendMessage(decodedText, false, contactNameSpan.textContent); } 
                    catch (e) { console.warn("DATA_RECV_STRING: Failed Base64 decode. Error:", e); appendMessage(String(data), false, contactNameSpan.textContent); }
                } else if (typeof data === 'object' && data.type === 'call-signal') { // Example for future call signaling via data channel
                     console.log("DATA_RECV_CALL_SIGNAL:", data);
                     // handleCallSignal(data); 
                } else { console.warn("DATA_RECV: Received non-string/unknown object data on DataConnection:", data); }
            });
            dataConnection.on('close', () => {  console.warn(`DATA_CONN_CLOSE: With ${dataConnection.peer}.`); showError(`üíî ${contactNameSpan.textContent} disconnected (data channel).`); endCallCleanup(); /* End call if data channel closes */});
            dataConnection.on('error', err => { console.error(`DATA_CONN_ERROR: With ${dataConnection.peer}:`, err); showError(`‚ö†Ô∏è Data connection error with ${contactNameSpan.textContent}: ${err.type || err.message}`); endCallCleanup(); /* End call on data channel error */});
        }
        
        function switchToChatPage() { console.log("SWITCH_TO_CHAT_PAGE: Called."); if (homePageEl && chatPageEl) { homePageEl.style.display = 'none'; chatPageEl.style.display = 'flex'; if(messageInput) messageInput.focus(); console.log("SWITCH_TO_CHAT_PAGE: Switched."); } else { console.error("SWITCH_TO_CHAT_PAGE: Elements NULL!"); alert("Critical: Page elements missing."); }}
        
        function appendMessage(text, isSender, senderDisplayName = "Friend") { const messageEl = document.createElement('div'); messageEl.classList.add('message'); let fullText; if (senderDisplayName === "System") { messageEl.classList.add('system'); fullText = text; } else if (isSender) { messageEl.classList.add('sent'); fullText = `You: ${text}`; } else { messageEl.classList.add('received'); const display = senderDisplayName || "Friend"; fullText = `${display}: ${text}`; } messageEl.textContent = fullText; messagesDiv.appendChild(messageEl); messagesDiv.scrollTop = messagesDiv.scrollHeight; }

        function sendMessage() {
            const textMessage = messageInput.value.trim();
            console.log(`SEND_ACTION_TEXT: Attempting: "${textMessage}"`);
            if (!conn || !conn.open) { showError('‚ö†Ô∏è Not connected.'); return; }
            if (textMessage) {
                try { 
                    const encodedText = btoa(unescape(encodeURIComponent(textMessage))); 
                    conn.send(encodedText); 
                    appendMessage(textMessage, true); 
                    messageInput.value = ''; messageInput.focus();
                } catch (e) { console.error("SEND_MSG_ERROR: Encoding Base64:", e); showError("‚ùå Error sending message."); }
            } else { console.log("SEND_ACTION_TEXT: No text to send."); }
        }

        // ----- MEDIA CALL FUNCTIONS -----
        async function getLocalMedia(constraints) {
            console.log("MEDIA_ACCESS: Requesting with constraints:", constraints);
            if (localStream) { console.log("MEDIA_ACCESS: Stopping existing local stream tracks."); localStream.getTracks().forEach(track => track.stop()); localStream = null; }
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                localStream = stream;
                localVideoEl.srcObject = stream; 
                localVideoEl.style.display = (constraints.video) ? 'block' : 'none';
                console.log("MEDIA_ACCESS: Local stream obtained. Video enabled:", !!constraints.video);
                return stream;
            } catch (err) {
                console.error("MEDIA_ACCESS_ERROR:", err);
                showError(`‚ùå Media Error: ${err.name}. Check permissions.`, 6000);
                endCallCleanup(); 
                return null;
            }
        }

        async function startCallAttempt(callType) { 
            if (!conn || !conn.open || !conn.peer) { showError("‚ö†Ô∏è Not connected to friend to start call."); return; }
            if (currentCall) { showError("‚ö†Ô∏è Already in a call."); return; }
            console.log(`CALL_INITIATE: Attempting ${callType} call with ${conn.peer}`);
            
            const constraints = callType === 'video' ? { video: true, audio: true } : { audio: true, video: false };
            const stream = await getLocalMedia(constraints);
            if (!stream) { showError(`‚ùå Could not start ${callType} call: Media access failed.`); return; }

            showCallUI(callType); 
            connectionStatusEl.textContent = `üìû Calling ${contactNameSpan.textContent || conn.peer}... (${callType})`;
            
            const call = peer.call(conn.peer, stream, { metadata: { callType: callType, callerName: friendNameInput.value.trim() || "A friend" } });
            if (call) {
                setupMediaCallEvents(call);
                currentCall = call;
                console.log(`CALL_INITIATE: MediaCall object created for ${callType} call to ${call.peer}.`);
            } else {
                console.error("CALL_INITIATE_ERROR: peer.call() failed. PeerJS might not be ready.");
                showError("‚ùå Error initiating call. Try again.", 6000);
                endCallCleanup(); 
            }
        }
        
        function showIncomingCallPrompt(callerNameToShow, callType) {
            const existingPrompt = document.getElementById('incoming-call-prompt-el');
            if (existingPrompt) existingPrompt.remove();
            const promptDiv = document.createElement('div');
            promptDiv.id = 'incoming-call-prompt-el';
            promptDiv.className = 'incoming-call-prompt message system';
            promptDiv.innerHTML = `<p>üìû Incoming ${callType} call from ${callerNameToShow}!</p> <button class="accept-call">Accept</button> <button class="reject-call">Reject</button>`;
            messagesDiv.appendChild(promptDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            promptDiv.querySelector('.accept-call').onclick = async () => {
                promptDiv.remove();
                if (!incomingCallInstance) { console.error("INCOMING_CALL_ERROR: No instance to accept."); return; }
                console.log("INCOMING_CALL_ACCEPT: User accepted from", incomingCallInstance.peer);
                const constraints = (callType === 'video') ? { video: true, audio: true } : { audio: true, video: false };
                const stream = await getLocalMedia(constraints); 
                if (!stream) { showError("‚ùå Could not accept call: Media access failed."); incomingCallInstance.close(); incomingCallInstance = null; return; }
                
                showCallUI(callType);
                incomingCallInstance.answer(stream); 
                setupMediaCallEvents(incomingCallInstance);
                currentCall = incomingCallInstance;
                incomingCallInstance = null; 
            };
            promptDiv.querySelector('.reject-call').onclick = () => {
                promptDiv.remove();
                if (incomingCallInstance) { console.log("INCOMING_CALL_REJECT: User rejected from", incomingCallInstance.peer); incomingCallInstance.close(); incomingCallInstance = null; }
            };
        }

        function setupMediaCallEvents(mediaCall) {
            console.log("SETUP_MEDIA_CALL_EVENTS: For call with", mediaCall.peer);
            mediaCall.removeAllListeners(); 

            mediaCall.on('stream', remoteStream => {
                console.log("MEDIA_CALL_STREAM: Received remote stream from", mediaCall.peer);
                remoteVideoEl.srcObject = remoteStream;
                remoteVideoEl.play(); // Ensure video plays
                remoteVideoEl.style.display = 'block';
                // Ensure local video is displayed based on whether it's a video call and video is enabled
                const isVideoCall = mediaCall.metadata && mediaCall.metadata.callType === 'video';
                if (localStream && isVideoCall && localStream.getVideoTracks().some(t => t.enabled && !t.muted)) {
                    localVideoEl.style.display = 'block';
                } else {
                    localVideoEl.style.display = 'none';
                }
                connectionStatusEl.textContent = `üìû In call with ${contactNameSpan.textContent || mediaCall.peer}`;
                videoCallContainer.style.display = 'flex'; 
            });
            mediaCall.on('close', () => { console.log("MEDIA_CALL_CLOSE: Call with", mediaCall.peer, "closed."); showError(`Call with ${contactNameSpan.textContent || mediaCall.peer} ended.`); endCallCleanup(); });
            mediaCall.on('error', err => { console.error("MEDIA_CALL_ERROR: With", mediaCall.peer, err); showError(`‚ö†Ô∏è Call error: ${err.message || err.type || 'Unknown error'}`); endCallCleanup(); });
        }

        function showCallUI(callType) {
            console.log("UI_UPDATE: Showing call UI for type:", callType);
            videoCallContainer.style.display = 'flex';
            messagesDiv.style.display = 'none'; 
            document.querySelector('.chat-input-area').style.display = 'none'; 
            toggleVideoBtn.style.display = (callType === 'video') ? 'flex' : 'none'; 
            if (localStream && callType === 'video' && localStream.getVideoTracks().length > 0 && localStream.getVideoTracks()[0].enabled) {
                localVideoEl.style.display = 'block';
            } else if (callType === 'audio') { localVideoEl.style.display = 'none'; }
            // Request fullscreen when call UI is shown
            // if (videoCallContainer.requestFullscreen) {
            //     videoCallContainer.requestFullscreen().catch(err => console.warn("Fullscreen request failed:", err.message));
            // } // Add vendor prefixes if needed
        }
        function hideCallUI() {
            console.log("UI_UPDATE: Hiding call UI.");
            videoCallContainer.style.display = 'none';
            messagesDiv.style.display = 'block'; 
            document.querySelector('.chat-input-area').style.display = 'flex'; 
            connectionStatusEl.textContent = "üîí P2P Encrypted"; 
            // Exit fullscreen if active
            // if (document.fullscreenElement) { document.exitFullscreen().catch(err => console.warn("Exit fullscreen failed:", err.message)); }
        }
        
        function endCall() {
            console.log("END_CALL: User initiated hang up.");
            if (currentCall) { currentCall.close(); } 
            else { endCallCleanup(); } 
        }

        function endCallCleanup() {
            console.log("END_CALL_CLEANUP: Cleaning up.");
            if (localStream) { localStream.getTracks().forEach(track => track.stop()); console.log("END_CALL_CLEANUP: Local stream tracks stopped."); }
            localStream = null;
            localVideoEl.srcObject = null; localVideoEl.style.display = 'none';
            remoteVideoEl.srcObject = null; remoteVideoEl.style.display = 'none';
            currentCall = null; incomingCallInstance = null; 
            hideCallUI();
            const existingPrompt = document.getElementById('incoming-call-prompt-el');
            if (existingPrompt) existingPrompt.remove();
            toggleMicBtn.textContent = 'üé§'; toggleVideoBtn.textContent = 'üìπ'; isSpeakerphoneOn = false; toggleSpeakerBtn.textContent = 'üîä';
        }

        function toggleMicrophone() {
            if (!localStream || localStream.getAudioTracks().length === 0) { console.warn("TOGGLE_MIC: No local audio track."); return; }
            const audioTrack = localStream.getAudioTracks()[0];
            audioTrack.enabled = !audioTrack.enabled;
            toggleMicBtn.textContent = audioTrack.enabled ? 'üé§' : 'üîá';
            console.log("TOGGLE_MIC:", audioTrack.enabled ? "Unmuted" : "Muted");
            appendMessage(`You ${audioTrack.enabled ? 'unmuted' : 'muted'} your mic.`, true, "System");
        }
        function toggleCamera() {
            if (!localStream || localStream.getVideoTracks().length === 0) { console.warn("TOGGLE_VIDEO: No local video track. Possibly an audio-only call."); toggleVideoBtn.style.display = 'none'; return; }
            const videoTrack = localStream.getVideoTracks()[0];
            videoTrack.enabled = !videoTrack.enabled;
            toggleVideoBtn.textContent = videoTrack.enabled ? 'üìπ' : 'üì∏'; 
            localVideoEl.style.display = videoTrack.enabled ? 'block' : 'none';
            console.log("TOGGLE_VIDEO:", videoTrack.enabled ? "Video On" : "Video Off");
            appendMessage(`You turned video ${videoTrack.enabled ? 'on' : 'off'}.`, true, "System");
        }
        
        async function toggleSpeaker() {
            if (!remoteVideoEl || !remoteVideoEl.srcObject) { showError("üîä No active call to toggle speaker."); return; }
            if (typeof remoteVideoEl.setSinkId !== 'function') { showError("üîä Speaker toggle not supported by this browser.", 4000); return; }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                console.log("AUDIO_OUTPUT_DEVICES:", audioOutputDevices.map(d=> ({id: d.deviceId, label:d.label, kind: d.kind, groupId: d.groupId })));

                if (audioOutputDevices.length < 2 && !isSpeakerphoneOn) { 
                     // If less than 2, or only one and speaker is not 'on', assume it's already earpiece or only option.
                     // Try to force speaker by playing a new audio element (hacky, might not work)
                    console.warn("SPEAKER_TOGGLE: Less than 2 audio outputs, or trying to turn off speaker when only one option. Attempting hack.");
                    // This hack is very unreliable for forcing loudspeaker.
                    // Better to inform user if explicit toggle isn't possible.
                    showError("üîä Speaker toggle might not work if only one audio output is found.", 4000);
                    isSpeakerphoneOn = !isSpeakerphoneOn; // Toggle state anyway for UI
                    toggleSpeakerBtn.textContent = isSpeakerphoneOn ? 'üîà' : 'üîä'; // Speaker off (earpiece) / Speaker on
                    return;
                }
                
                let targetDeviceId = 'default'; // Default to system default (usually earpiece)
                if (!isSpeakerphoneOn) { // If currently not on speaker, switch TO speaker
                    // Try to find a device explicitly labeled 'speaker'
                    const speakerDevice = audioOutputDevices.find(d => d.label.toLowerCase().includes('speaker'));
                    if (speakerDevice) {
                        targetDeviceId = speakerDevice.deviceId;
                    } else if (audioOutputDevices.length > 1) {
                        // If no explicit 'speaker', try the non-default one (if 'default' is earpiece)
                        // Or, if 'default' IS the speaker, we need to find the earpiece. This is tricky.
                        // For simplicity, if we don't find 'speaker', we'll toggle to the first non-default or back to default.
                        // This logic needs more robust device identification.
                        targetDeviceId = audioOutputDevices.find(d => d.deviceId !== 'default' && d.deviceId !== '')?.deviceId || audioOutputDevices[0].deviceId; 
                        console.log("SPEAKER_TOGGLE: No explicit 'speaker' device found, trying deviceId:", targetDeviceId);
                    }
                }
                // If isSpeakerphoneOn is true, targetDeviceId remains 'default' to switch OFF speaker.

                console.log(`SPEAKER_TOGGLE: Attempting to setSinkId to: ${targetDeviceId}`);
                await remoteVideoEl.setSinkId(targetDeviceId);
                isSpeakerphoneOn = (targetDeviceId !== 'default' && audioOutputDevices.find(d=>d.deviceId === targetDeviceId)?.label.toLowerCase().includes('speaker')); // Update state
                
                toggleSpeakerBtn.textContent = isSpeakerphoneOn ? 'üîà' : 'üîä';
                showError(`üîä Switched to ${isSpeakerphoneOn ? 'Loudspeaker' : 'Earpiece/Default'}.`, 2000);
                console.log("SPEAKER_TOGGLE: Switched. New sinkId:", remoteVideoEl.sinkId, "isSpeakerphoneOn:", isSpeakerphoneOn);

            } catch (err) {
                console.error("SPEAKER_TOGGLE_ERROR:", err);
                showError("‚ùå Error toggling speaker: " + err.message, 4000);
            }
        }

        // ----- Initial UI Setup ----- 
        function initialUISetup() { peerIdInput.value = ''; copyIdBtn.style.display = 'none'; applySavedTheme(); setupEventListeners(); console.log("UI_INIT: Initial setup complete. Event listeners attached.");}
        document.addEventListener('DOMContentLoaded', initialUISetup);
    </script>
</body>
</html>
